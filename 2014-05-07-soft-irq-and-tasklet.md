---
layout:    post
title:     软中断和tasklet
category:  中断和异常
description: 软中断和tasklet...
tags: 软中断 tasklet
---
在由内核执行的几个任务之间有些不是紧急的，在必要的情况下它们可以被推迟一段时间。一个中断处理程序的几个中断服务例程之间时串行执行的，并且通常在一个中断的处理程序结束前，不应该再次出现这个中断。

相反，可延迟中断可以在开中断的情况下执行，把可延迟中断从中断处理程序中抽出来有助于内核保持较短的响应时间。这对于哪些期望它们的中断能在几号秒内大刀处理的『急迫』应用来说是非常重要的。Linux 2.6通过可延迟函数和工作队列来执行的函数来实现以上问题。

软中断和tasklet有密切的关系，tasklet是在软中断之上的实现，事实上，出现在内核代码中的术语软中断（*softirq*）通常表示可延迟函数的所有种类，另外一种被广泛使用的术语是『中断上下文』，中断上下文表示当前正在执行一个中断处理程序或一个可延迟的函数。

软中断的分配是静态的，即在编译时定义的，而tasklet的分配和初始化可以在运行时进行。软中断可以并发地运行在多个CPU上，因此软中断是可重入函数并且必须明确地使用自旋锁保护其数据结构。但tasklet不必担心这些问题，因为内核对tasklet的执行进行了更加严格的控制。

相同类型的tasklet总是被串行地执行，所以说不能在两个CPU上同事运行相同类型的tasklet，但是类型不同的tasklet可以在几个CPU上并发执行。tasklet的串行化使tasklet函数不必是可重入的，因此简化了驱动设备程序开发者的工作。

一般而言，在可延迟函数上可以执行四种操作：

**初始化**（*initialization*）

定义一个新的可延迟函数，这个操作通常在内核自身初始化或加载模块时进行。

**激活**（*activation*）

标记一个可延迟函数为『挂起』，激活可以在任何时候进行，即便正在处理中断。

**屏蔽**（*masking*）

有选择地屏蔽一个可延迟函数，这样，即使它被激活，内核也不执行它。

**执行**（*execution*）

执行一个挂起的可延迟函数和同类型的其他所有挂起的可延迟函数，执行是在特定的时间进行的。

激活和执行总是捆绑在一起的。由给定CPU激活的一个可延迟函数必须在同一个CPU上执行，不过并没有什么明显的理由说明这条规则是对系统有益的。把可延迟函数绑定在激活CPU上从理论上说可以更好地利用CPU地硬件高速缓存，毕竟，激活地内核线程访问一些数据结构，可延迟函数也可能会使用。

然而，当可延迟函数运行时，因为它地执行可能延迟一段时间，因此相关地高速缓存行可能就根本不再高速缓存中了，因此，帮一个函数绑定在一个CPU上总是有潜在『危险』的操作，因为一个CPU可能忙死而其他CPU又无所事事。