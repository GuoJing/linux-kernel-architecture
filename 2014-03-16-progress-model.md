---
layout:    post
title:     进程内核模式
category:  基础
description: 进程内核模式...
tags: 进程实现
---
内核把虚拟空间地址划分为两个部分，因此能够保护各个系统进程，使它们彼此隔离起来。所有的现代的CPU都提供了几种特权级别，进程可以驻留在某一个特权级别。每个特权级别都有一些限制，例如对执行某些指令的限制，或者访问特定空间的限制。

各种不同的计算机有不同的特权级别限制，Linux通常只使用两种不同的状态：核心态和用户态。两种状态的关键差别在于对高于TASK\_SIZE的地址区域的访问。简而言之，用户状态的进程无法访问高于TASK\_SIZE地址的内存，也无法执行内核空间的代码，这个区域是内核的专用区别。当然，如果用户处于核心态的话，这种限制就不再满足。

从用户态到核心态的切换通过**系统调用**的特定转换手段完成，且系统调用的执行因具体系统而不同。如果普通进程想要执行任何影响整个系统的操作，则只能借助于系统调用向内核发送请求。内核首先会进行权限的检查，执行所需操作，返回到用户态。

进程是动态的实体，在系统内通常只有有限的生存期。内核本身并不是一个进程，而是进程的管理者。除此之外，系统还可能包括所谓的内核线程的特权进程，它们具有：

1. 以内核态运行在内核地址空间。
2. 不与用户直接交互。
3. 通常在系统启动时创建，然后一直活跃直到关闭。

不过在其他许多方面，内核线程更像是普通的用户层应用程序。

除了代表用户程序执行代码以外，内核还可以由异步硬件中断激活，然后在上下文中运行。在中断上下文运行时，内核必须比正常情况更加谨慎，例如，不能进入睡眠状态。

在单处理器系统中，任何时候只有一个进程在运行，要么处于用户态，要么处于内核态。如果运行在内核态，处理器就执行一些内核例程。例如一个进程处于用户态，发出系统调用之后，进入内核态，然后系统调用被执行。直到发生定时中断并且调度程序在内核态被激活，进程才恢复到用户态。

可以有几种方式激活内核例程：

1. 进程执行系统调用。
2. 正在执行进程的CPU发生一个异常。
3. 外围设备向CPU发出一个中断[^1]。
4. 内核线程被执行。

[^1]: 例如读取文件，等待读取完毕之前，内核会暂时睡眠进程，直到I/O完毕之后，会产生一个中断，给进程发送信号进行通知。

### 进程实现 ###

为了让内核管理进程，每个进程由一个进程描述符（*process descriptor*）表示。当内核暂停一个执行的进程，就把几个相关处理器寄存的内容保存在进程描述符中，这些寄存器包括：

1. 程序计数器（PC）和栈指针（SP）寄存器。
2. 通用寄存器。
3. 浮点寄存器。
4. 包含CPU状态信息的处理器控制寄存器。
5. 用来跟踪进程对RAM访问的内存管理寄存器。

当内核恢复一个进程，它用进程描述符中合适的字段来装载CPU寄存器。当进程不在CPU上执行时，它正在等待某一事件，例如外围设备的中断。[^2]

[^2]: 如等待键盘输入。