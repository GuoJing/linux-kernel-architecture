---
layout:    post
title:     进程、轻量级进程和线程
category:  进程
description: 进程、轻量级进程和线程...
tags: 线程 轻量级进程
---

### 进程 ###

现在的所有计算机都有进程的概念，它可以让用户觉得计算机是在运行多个程序，而实际上只有CPU个数的进程在工作，如果处理进程之间的调度，是内核非常重要的工作。内核必须要处理好调度工作，让用户有*多任务*的错觉。

内核进行进程调度，必须解决如下几个问题：

1. 除非明确地要求，否则应用程序不能彼此干扰。
2. CPU时间必须在各个应用程序之间尽量公平的共享。

上面的两个需求，其中第一个需求，就是存储保护。例如程序A不能干扰程序B的数据空间，不能使用到程序B的内存造成程序B的崩溃。这里必须有两个任务，并且其执行是相对独立的。另外，内核必须决定为各个进程分配多少CPU时间，什么时候切换到下一个进程。这又引出了哪个进程是下一个进程的问题，而且这种解决方法必须是平台无关的。

另外，内核从进程A切换到进程B，需要将进程A的上下文保存起来，并且在下一次恢复到进程A的时候，恢复进程的上下文。进程A不会感知到进程B，可以这么说，进程A会认为自己是计算机中唯一的进程，而且也无需共享空间。为了造成这种错觉，需要在切换和恢复的时候，保留和恢复上下文。这一项工作并不纯粹的是C语言实现，CPU和各种硬件提供了寄存器的访问还需要汇编的帮助。

从内核观点来看，进程的目的就是担当分配系统资源的实体。当一个进程创建时，它几乎与父进程相同，它接受父进程地址空间的一个逻辑拷贝，并从进程创建系统调用的下一条指令开始执行与父进程相同的代码。尽管父子进程可以共享一个内存单元。但子进程的修改对父进程是不可见的。

### 线程 ###

线程可以看做是很多相对独立的执行流，并且共享应用程序的大部分数据结构，在这样的系统中，一个进程由多个用户线程组成，每个线程都代表一个执行流。现在，大部分多线程应用程序都是用*pthread*（*POSIX thread*）库的标准函数库编写。

### 轻量级进程 ###

Linux使用轻量级进程（*lightweight process*）对多线程应用程序提供支持。两个轻量级进程可以共享一些资源，比如地址空间、打开文件。只要其中一个修改共享资源，另一个就能立马感知到这种修改。

实现多线程的应用程序的一个简单方式就是把轻量级进程与每个线程关联起来。这样，线程之间就可以通过简单地共享同一内存地址空间、同一打开文件等来访问相同的应用程序的数据结构。同时，每个线程都可以由内核独立调度，以便一个睡眠的同时另一个仍然是可以运行的。