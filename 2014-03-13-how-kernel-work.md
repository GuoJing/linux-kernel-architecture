---
layout:    post
title:     内核
category:  基础
description: 内核的任务，以及内核的一些工作...
tags: 微内核 宏内核 模块 代码结构
---
什么是内核，内核做什么的呢？内核有哪些需要了解的概念？

### 内核的任务 ###

在纯技术层面上，内核是硬件与软件之间的一个中间层。其作用是将应用程序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。尽管如此，仍然可以从其他一些有趣的视角对内核进行研究。

1. 从应用程序的视角来看，内核可以被认为是一台`增强的计算机`，将计算机抽象到一个高的层次上。比如，在内核寻址硬盘时，它必须确定使用哪个路径来从磁盘向内存复制数据，数据的位置，从哪个路径向磁盘发送哪一条命令，等等。另一方面，应用程序只需发出传输数据的命令。实际的工作如何完成与应用程序是不相关的，因为内核抽象了相关的细节。应用程序与硬件喷神没有联系，只与内核有联系，内核是应用程序所知道的层次结构中的最底层。
2. 当若干程序在同一系统中并发运行时，也可以将内核视为`资源管理程序`。在这种情况下，内核负责将可用共享资源（如CPU时间、磁盘空间、网络连接）分配到各个系统进程，同事还需要保证系统的完整性。
3. 另一种研究内核的视角是将内核视为库，其提供了一组面相系统的命令。比如说，系统调用用于向计算机发送请求，借助于C标准库，系统调用对于应用程序就像是普通函数一样。

### 实现策略 ###

微内核

只有最基本的功能直接由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与重心内核通信。比如说，独立进程可能负责实现各种文件系统，内存管理等等。理论上，这是一种很完美的实现方法，因为系统各个部分彼此都很清楚的划分开来，同时也能够让程序员使用干净的程序。这种方法的好处也包括：动态可扩展性和在运行时切换重要的组件。

宏内核

与微内核相反，宏内核是构建系统内核的传统方法。在这种方法中，内核的全部代码都打包到一个文件中。内核中的每个函数都可以访问内核中其他部分。如果编程不小心，可能导致代码中出现复杂的嵌套。目前Linux依旧是使用宏内核。

不过其中有了一个重要革新，就是在系统运行中，模块可以插入到内核代码中，也可以移除，这使得可以向内核动态添加功能，弥补了宏内核的一些缺陷。

### 模块 ###

为了达到微内核理论上很多的优点又不影响性能，Linux内核提供了模块（module）。模块是一个目标文件，其代码可以运行在运行时链接到内核或从内核解除链接。这种目标代码通常由一组函数组成，用来实现文件系统、驱动程序或其他内核上层功能。与微内核操作系统的外层不同，模块不是作为一个特殊的进程执行的。相反，与任何其他静态链接的内核函数一样，它代表当前进程在内核态下执行。

模块的优点包括：

1. 模块化方法：任何模块都可以运行时被链接或解除，开发模块变得容易。
2. 平台无关性：即使依赖于某些特殊的硬件特点，但它也不依赖于固定的硬件平台。
3. 节省内存使用：只有需要模块功能时，才把它链接到正在运行的内核中。
4. 无性能损失：模块的目标代码一旦被链接倒内核，其作用与静态链接的内核的目标代码完全等价。

### 内核的代码结构 ###

内核代码包含了操作系统的方方面面，了解代码结构有助于帮助我们深入的查找内核代码。

文件夹             | 说明
------------      | -------------
arch              | 所有与体系结构相关的代码，例如arm、x86、a_64等不同体系结构的核心文件。
include           | 所有编译需要的核心头文件。
init              | 包含核心的初始化代码。
mm                | 包含内存管理的代码。
kernel            | 内核的主要代码。
drivers           | 驱动的主要代码。
fs                | 文件系统的各种操作代码。
